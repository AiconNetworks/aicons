# Hierarchical Bayesian Implementation Plan

## Overview
This document outlines the step-by-step implementation plan for understanding and testing the existing hierarchical Bayesian modeling in the BayesBrain system. The system already has a robust state representation with hierarchical capabilities through `HierarchicalLatentVariable` and `BayesianState` classes.

## Current State
We already have:
1. **State Representation**:
   - `HierarchicalLatentVariable` for hierarchical relationships
   - `BayesianState` with hierarchical relations and joint distributions
   - Support for continuous, categorical, and discrete variables
   - Continuous relaxation for MCMC sampling

2. **Perception System**:
   - MCMC sampling with proper bijectors
   - Continuous relaxation for categorical/discrete variables
   - Hierarchical joint distributions

## Next Steps

### Phase 1: Understand Current Implementation
**Goal**: Completely understand how the current hierarchical system works

#### Task 1.1: Document Current Behavior
```python
def test_basic_hierarchy():
    """
    Test basic hierarchical structure:
    1. Create a simple hierarchy (global -> group -> individual)
    2. Verify relationships are correct
    3. Check joint distribution structure
    """
```

**Test Cases**:
```python
def test_hierarchy_structure():
    # Create a simple marketing hierarchy
    state = BayesianState()
    
    # Add global parameter
    state.add_latent_variable(
        "noise_scale",
        ContinuousLatentVariable(
            name="noise_scale",
            prior=tfd.HalfNormal(1.0)
        )
    )
    
    # Add group parameter
    state.add_latent_variable(
        "marketing",
        HierarchicalLatentVariable(
            name="marketing",
            parent="noise_scale",
            prior=lambda noise: tfd.Normal(0, noise)
        )
    )
    
    # Add individual parameter
    state.add_latent_variable(
        "campaign_1",
        HierarchicalLatentVariable(
            name="campaign_1",
            parent="marketing",
            prior=lambda marketing: tfd.Normal(marketing, 0.1)
        )
    )
    
    # Verify structure
    assert state.get_hierarchy_levels() == ["noise_scale", "marketing", "campaign_1"]
    assert state.get_parent("campaign_1") == "marketing"
    assert state.get_parent("marketing") == "noise_scale"
```

### Phase 2: Test MCMC Sampling
**Goal**: Verify MCMC sampling works correctly for hierarchical structure

#### Task 2.1: Basic Sampling Tests
```python
def test_hierarchical_sampling():
    """
    Test MCMC sampling:
    1. Sample from prior
    2. Sample from posterior with observations
    3. Verify samples respect hierarchy
    """
```

**Test Cases**:
```python
def test_sampling_behavior():
    # Create test hierarchy
    state = create_test_hierarchy()
    
    # Test prior sampling
    prior_samples = state.sample_prior()
    assert prior_samples["noise_scale"] > 0  # HalfNormal constraint
    assert "marketing" in prior_samples
    assert "campaign_1" in prior_samples
    
    # Test posterior sampling with observations
    observations = {
        "campaign_1": 0.5
    }
    posterior_samples = state.sample_posterior(observations)
    assert posterior_samples["campaign_1"] is not None
    # Verify samples respect hierarchy
    assert posterior_samples["marketing"] is not None
    assert posterior_samples["noise_scale"] is not None
```

### Phase 3: Test Continuous Relaxation
**Goal**: Verify continuous relaxation works for categorical/discrete variables

#### Task 3.1: Relaxation Tests
```python
def test_continuous_relaxation():
    """
    Test continuous relaxation:
    1. Test categorical variables
    2. Test discrete variables
    3. Verify gradients flow correctly
    """
```

**Test Cases**:
```python
def test_relaxation():
    # Test categorical variable
    state = BayesianState()
    state.add_latent_variable(
        "category",
        CategoricalLatentVariable(
            name="category",
            num_categories=3,
            prior=tfd.Dirichlet([1.0, 1.0, 1.0])
        )
    )
    
    # Test discrete variable
    state.add_latent_variable(
        "count",
        DiscreteLatentVariable(
            name="count",
            min_value=0,
            max_value=10,
            prior=tfd.Poisson(5.0)
        )
    )
    
    # Verify relaxation works
    samples = state.sample_prior()
    assert samples["category"].shape == (3,)  # Probability vector
    assert samples["count"] >= 0 and samples["count"] <= 10
```

### Phase 4: Integration Tests
**Goal**: Test full system integration

#### Task 4.1: End-to-End Tests
```python
def test_full_system():
    """
    Test complete system:
    1. Create complex hierarchy
    2. Add observations
    3. Run inference
    4. Verify results
    """
```

**Test Cases**:
```python
def test_complex_hierarchy():
    # Create a complex marketing hierarchy
    state = create_marketing_hierarchy()
    
    # Add observations
    observations = {
        "campaign_1": {"conversion_rate": 0.3},
        "campaign_2": {"conversion_rate": 0.4},
        "campaign_3": {"conversion_rate": 0.5}
    }
    
    # Run inference
    results = state.run_inference(observations)
    
    # Verify results
    assert "global_params" in results
    assert "group_params" in results
    assert "individual_params" in results
```

## Success Metrics

1. **Functionality**:
   - All test cases passing
   - Correct hierarchical relationships
   - Proper sampling behavior
   - Working continuous relaxation

2. **Correctness**:
   - Samples respect constraints
   - Hierarchical dependencies maintained
   - Proper posterior updates

3. **Integration**:
   - All components work together
   - No unexpected behavior
   - Clear error messages

## Next Immediate Steps

1. Start with Phase 1: Understanding
   - Review current implementation
   - Create basic test cases
   - Document behavior

2. Move to Phase 2: Testing
   - Test MCMC sampling
   - Verify hierarchy
   - Check constraints

3. Then Phase 3: Relaxation
   - Test categorical variables
   - Test discrete variables
   - Verify gradients

## Notes

- Focus on understanding before optimization
- Test each component thoroughly
- Document all findings
- Fix any issues before moving forward
